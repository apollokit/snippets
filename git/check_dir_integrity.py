"""Check the integrity of the build dir

checks:
1. We have a file that has a symlink in dir, but doesn't exist as a real file in source. 
    This happens when you create a file in source, build, and then delete the source file. 
    Could cause confusion because there's still "code" in build that can be imported. 
2. A non-symlink, human-created code file exists in build, but not source. 

"""

import os
from os import path

REPO_ROOT = '../../..'
BUILD_PATH = path.join(REPO_ROOT, 'build')

# for manual use, not in git hook. List every symlink that exists in build but
#  doesn't have a corresponding file in source
LIST_ALL_NONEXISTANT_SYMLINKS=False

import mmap

def string_in_file(filepath: str, string: str) -> bool:
    # if the file is empty, the string is definitely not in it
    if os.path.getsize(filepath) == 0:
        return False
    # Memory efficient way to search for the string in a file, from https://stackoverflow.com/a/4944929/4292910
    with open(filepath, 'rb', 0) as file, mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:
        if s.find(string.encode('utf-8')) != -1:
            return True
    return False

def handle_symlink_file(filepath):
    # we know it's a symbolic link; get the path to the real file
    file_realpath = path.realpath(filepath)

    if not path.exists(file_realpath):
        # if we get here, then we have a file that has a symlink in build, but 
        # doesn't exist as a real file in source. 
        print(f"{__file__}: file {filepath} is a symlink in build, but doesn't exist in src dir (at {file_realpath})")
        
        # if true, continue printing all the file names, because I ran into a 
        # lot of them and wanted to see them all listed at once
        if LIST_ALL_NONEXISTANT_SYMLINKS:
            pass
        else:
            # exit with nonzero status code to trip the git hook
            exit(1)
    
for (dir, subdirs, files) in os.walk(BUILD_PATH):
    for file in files:
        file_abspath = path.abspath(path.join(dir, file))
        
        # only look at python files
        if not file.endswith('.py'):
            continue

        # symlinks
        if path.islink(file_abspath):
            handle_symlink_file(file_abspath)
        
        # not symlinks
        else:
            # don't care about swig generated files, those are created by basilisk
            if string_in_file(file_abspath, 
                    "This file was automatically generated by SWIG"):
                continue

            # don't care about init files, i think basilisk automatically 
            # generates these during the build
            if file == '__init__.py':
                continue

            # what we are now left with is non-symlink, human-created code files that
            # exist in build, but not starfish source. 
            print(f"{__file__}: file {file_abspath} exists in build as a non-symlink,"
                " this is not expected. Did you accidentally save it to build instead of source?")
            # exit with nonzero status code to trip the git hook
            exit(1)
